# SWITCH Scoring System - Final Design Document

## Core Scoring Philosophy

A momentum-based scoring system that rewards sustained skillful play over lucky single moves. Players build "heat" through complex matches and cascades, with momentum naturally decaying to create constant pressure for excellence.

## 1. Base Scoring Values

### Tile Values
```csharp
// Every tile has base value
const int TILE_BASE_VALUE = 10;

// Position multipliers (based on board zones)
const int EDGE_MULTIPLIER = 1;        // Outer ring (columns/rows 0,7)
const int TRANSITION_MULTIPLIER = 2;  // Middle ring (columns/rows 1-2, 5-6)
const int CENTER_MULTIPLIER = 3;      // Center 4 cells (3,3), (4,3), (3,4), (4,4)
```

### Special Pattern Bonuses
```csharp
// Additional points for special shapes (added to base)
const int L_SHAPE_BONUS = 50;     // L or T shaped matches
const int CROSS_BONUS = 100;      // + shaped matches (5-match)
```

## 2. Momentum Heat System

### Heat Generation
```csharp
public class MomentumSystem
{
    private float momentum = 0f;
    private const float MAX_MOMENTUM = 10f;
    
    // Heat generated by actions
    const float MATCH_3_HEAT = 0f;      // No heat - just maintains
    const float MATCH_4_HEAT = 1.0f;    // Good heat boost
    const float MATCH_5_HEAT = 2.0f;    // Excellent heat boost
    const float CASCADE_HEAT = 0.5f;    // Per cascade level (cumulative)
    const float L_SHAPE_HEAT = 1.0f;    // Pattern bonus heat
    const float CROSS_HEAT = 1.5f;      // Rare pattern heat
    
    // POWER ORB SPECIAL
    const float POWER_ORB_COLLECTED = MAX_MOMENTUM;  // Instant maximum!
    
    // Automatic decay
    const float TURN_END_DECAY = 1.0f;  // Always lose 1 heat per turn
}
```

### Multiplier Calculation
```csharp
// Convert momentum to score multiplier
public float GetScoreMultiplier()
{
    // At 0 momentum = 1x, at 10 momentum = 10x
    return 1f + (momentum * 0.9f);
}
```

### Heat Decay Rules
- Every turn ends with -1.0 heat (automatic decay)
- Match-3 adds 0 heat (maintains current level minus decay)
- No time-based decay (except in Time Trial mode)
- Heat cannot go below 0 or above 10

## 3. Power Orb Scoring Integration

### Power Orb Effects
```csharp
public void CollectPowerOrb(PowerOrb orb)
{
    if (orb.ReachedCorrectEdge())
    {
        // INSTANT MAX HEAT!
        momentum = MAX_MOMENTUM;
        
        // Orb also provides base points
        int orbPoints = 5000;
        
        // Apply current multiplier to orb points
        int totalOrbScore = orbPoints * GetScoreMultiplier();
    }
}
```

### Strategic Implications
- Collecting orb at low heat = massive immediate boost
- Collecting at high heat = "wastes" the max-out effect
- Creates risk/reward decisions about timing

## 4. Turn Scoring Flow

### Complete Turn Calculation
```csharp
public int CalculateTurnScore(TurnResult result)
{
    int baseScore = 0;
    float heatGained = 0f;
    
    // 1. Calculate base points from tiles
    foreach (Tile tile in result.clearedTiles)
    {
        int tilePoints = TILE_BASE_VALUE * GetPositionMultiplier(tile.position);
        baseScore += tilePoints;
    }
    
    // 2. Add pattern bonuses
    if (result.hasLShape) baseScore += L_SHAPE_BONUS;
    if (result.hasCross) baseScore += CROSS_BONUS;
    
    // 3. Calculate heat gain
    heatGained += GetMatchHeat(result.matchSize);
    heatGained += CASCADE_HEAT * result.cascadeLevel;
    if (result.hasLShape) heatGained += L_SHAPE_HEAT;
    if (result.hasCross) heatGained += CROSS_HEAT;
    
    // 4. Apply power orb if collected
    if (result.powerOrbCollected)
    {
        momentum = MAX_MOMENTUM;
    }
    else
    {
        momentum = Mathf.Min(momentum + heatGained, MAX_MOMENTUM);
    }
    
    // 5. Apply multiplier to entire turn
    float multiplier = GetScoreMultiplier();
    int finalScore = Mathf.RoundToInt(baseScore * multiplier);
    
    // 6. Apply turn-end decay
    momentum = Mathf.Max(0f, momentum - TURN_END_DECAY);
    
    return finalScore;
}
```

## 5. Scoring Examples

### Example 1: Building Momentum
**Turn 1: Match-3 (edge)**
- Base: 3 tiles × 10 × 1 = 30 points
- Heat: 0 + 0 - 1 = 0 (cold start)
- Multiplier: 1.0x
- Final: 30 points

**Turn 2: Match-4 with cascade (center)**
- Base: 4 × 10 × 3 = 120 (initial) + 90 (cascade) = 210
- Heat: 0 + 1.0 + 0.5 - 1 = 0.5
- Multiplier: 1.45x
- Final: 304 points

**Turn 3: Match-5 L-shape!**
- Base: 5 × 10 × 2 + 50 = 150 points
- Heat: 0.5 + 2.0 + 1.0 - 1 = 2.5
- Multiplier: 3.25x
- Final: 487 points

### Example 2: Power Orb Explosion
**Current Heat: 2.0 (struggling)**
**Collect Power Orb:**
- Orb base: 5,000 points
- Heat: INSTANT 10.0!
- Multiplier: 10x
- Turn total: 50,000 points!
**Next turn: Heat drops to 9.0**

## 6. Visual Heat Meter

### Display States
- **0-2:** [░░░░░░░░░░] COLD (Blue tint, no effects)
- **3-4:** [███░░░░░░░] WARM (Yellow tint, slight glow)
- **5-7:** [██████░░░░] HOT (Orange tint, pulsing glow)
- **8-9:** [████████░░] BLAZING (Red tint, flame particles)
- **10:** [██████████] INFERNO! (White-hot, screen effects)

### UI Implementation
- Top of heat meter shows multiplier: "x6.5"
- Bar fills left to right with color gradients
- Particle effects intensify with heat level
- Screen edge glows at high heat

## 7. Audio Integration

### Dynamic Audio System
```csharp
public class HeatAudioManager : MonoBehaviour
{
    // Background music layers
    AudioSource baseLayer;      // Always playing
    AudioSource rhythmLayer;     // Fades in at 3+ heat
    AudioSource melodyLayer;     // Fades in at 6+ heat
    AudioSource climaxLayer;     // Fades in at 9+ heat
    
    // Tempo changes
    float baseBPM = 120f;
    float GetCurrentBPM() 
    {
        return baseBPM + (momentum * 6f);  // Max 180 BPM at full heat
    }
    
    // Sound effects
    AudioClip[] heatUpSounds;   // Pitched up with heat level
    AudioClip[] coolDownSound;  // Descending tone
    AudioClip infernoBurst;      // Plays at max heat
    
    // Heartbeat effect (optional)
    float heartbeatInterval = 1f - (momentum * 0.08f);  // Faster at high heat
}
```

### Audio Behavior
- **0-2 Heat:** Calm, ambient music
- **3-5 Heat:** Rhythm section joins, slight tempo increase
- **6-8 Heat:** Full melody, noticeable tempo boost
- **9-10 Heat:** Climactic music, fast tempo, heartbeat effect
- **Power Orb Collection:** Explosive audio surge
- **Heat Loss:** Descending musical stinger

## 8. Implementation Priority

### Phase 1 (MVP)
- Basic momentum system with visual meter
- Score multiplier display
- Turn-end decay
- Power orb instant-max mechanic

### Phase 2 (Polish)
- Particle effects for heat levels
- Screen edge glows
- Animated heat meter
- Basic audio tempo changes

### Phase 3 (Post-Launch)
- Full layered audio system
- Advanced visual effects
- Heat-based achievements
- Leaderboard heat statistics

## 9. Balancing Notes

### Tuning Variables (for playtesting)
```csharp
// These values can be adjusted based on testing
[SerializeField] float match4HeatValue = 1.0f;
[SerializeField] float cascadeHeatValue = 0.5f;
[SerializeField] float turnDecayRate = 1.0f;
[SerializeField] float maxMomentum = 10f;
[SerializeField] float multiplierScale = 0.9f;  // How much each heat point multiplies
```

### Expected Behavior
- Average player maintains 2-4 heat
- Skilled players sustain 5-7 heat
- Expert players spike to 10 with orbs
- Heat rarely stays at 10 for more than 1 turn

## 10. Success Metrics

### Scoring KPIs to Track
- Average heat level per session
- Percentage of turns at each heat level
- Power orb collection rate vs heat level
- Score distribution curves
- Player retention correlation with heat achieved

## Conclusion

This momentum-based scoring system creates a compelling risk/reward loop that rewards sustained excellence while providing explosive moments through power orbs. The automatic decay ensures players can never coast, making every turn matter.

The system encourages:
- **Skillful Play:** Complex matches and cascades build heat
- **Risk Management:** Power orb timing decisions
- **Sustained Excellence:** Decay prevents coasting
- **Explosive Moments:** Power orbs provide massive score spikes
- **Visual/Audio Feedback:** Clear indication of current state and progress
